RSpec.describe Metasploit::Cache::Exploit::Instance::Ephemeral::Stance do
  context 'is_stance_method' do
    subject(:is_stance_method) {
      described_class.is_stance_method(source_stance)
    }

    context 'with nil' do
      let(:source_stance) {
        nil
      }

      it { is_expected.to respond_to(:call) }

      context 'call(stance)' do
        subject(:comparison) {
          is_stance_method.call(potential_stance)
        }

        context 'with Metasploit::Cache::Module::Instance::AGGRESSIVE' do
          let(:potential_stance) {
            Metasploit::Cache::Module::Stance::AGGRESSIVE
          }

          it { is_expected.to eq(false) }
        end

        context 'with Metasploit::Cache::Module::Instance::AGGRESSIVE' do
          let(:potential_stance) {
            Metasploit::Cache::Module::Stance::PASSIVE
          }

          it { is_expected.to eq(false) }
        end
      end
    end

    context 'with Array' do
      let(:source_stance) {
        []
      }

      it { is_expected.to respond_to(:call) }

      context 'call(stance)' do
        subject(:comparison) {
          is_stance_method.call(potential_stance)
        }

        let(:potential_stance) {
          FactoryGirl.generate :metasploit_cache_module_stance
        }

        it 'calls #include?' do
          expect(source_stance).to receive(:include?)

          comparison
        end
      end
    end

    context 'with String' do
      let(:source_stance) {
        'not a stance'
      }

      it { is_expected.to respond_to(:call) }

      context 'call(stance)' do
        subject(:comparison) {
          is_stance_method.call(potential_stance)
        }

        let(:potential_stance) {
          FactoryGirl.generate :metasploit_cache_module_stance
        }

        it 'calls #==' do
          expect(source_stance).to receive(:==)

          comparison
        end
      end
    end
  end

  context 'synchronize' do
    include_context 'ActiveSupport::TaggedLogging'

    subject(:synchronize) {
      described_class.synchronize(
          destination: destination,
          logger: logger,
          source: source
      )
    }

    let(:destination) {
      Metasploit::Cache::Exploit::Instance.new(
          stance: 'Old Stance'
      )
    }

    let(:source) {
      double(
          'exploit Metasploit Module instance',
          stance: source_stance
      )
    }
    
    context 'with Array' do
      context 'containing Metasploit::Cache::Module::Stance::AGGRESSIVE and Metasploit::Cache::Module::Stance::PASSIVE' do
        let(:source_stance) {
          [
              Metasploit::Cache::Module::Stance::PASSIVE,
              Metasploit::Cache::Module::Stance::AGGRESSIVE
          ]
        }

        it 'sets destination.stance to Metasploit::Cache::Module::Stance::AGGRESSIVE' do
          expect {
            synchronize
          }.to change(destination, :stance).to(Metasploit::Cache::Module::Stance::AGGRESSIVE)
        end

        it 'returns destination' do
          expect(synchronize).to eq(destination)
        end
      end
    end

    context 'with String' do
      context 'with Metasploit::Cache::Module::Stance::AGGRESSIVE' do
        let(:source_stance) {
          Metasploit::Cache::Module::Stance::AGGRESSIVE
        }
        
        it 'sets destination.stance to Metasploit::Cache::Module::Stance::AGGRESSIVE' do
          expect {
            synchronize
          }.to change(destination, :stance).to(Metasploit::Cache::Module::Stance::AGGRESSIVE)
        end

        it 'returns destination' do
          expect(synchronize).to eq(destination)
        end
      end
      
      context 'with Metasploit::Cache::Module::Stance::PASSIVE' do
        let(:source_stance) {
          Metasploit::Cache::Module::Stance::PASSIVE
        }
        
        it 'sets destination.stance to Metasploit::Cache::Module::Stance::PASSIVE' do
          expect {
            synchronize
          }.to change(destination, :stance).to(Metasploit::Cache::Module::Stance::PASSIVE)
        end

        it 'returns destination' do
          expect(synchronize).to eq(destination)
        end
      end

      context 'with other' do
        let(:source_stance) {
          'Unrecognized Stance'
        }

        it 'sets destination.stance to nil' do
          expect {
            synchronize
          }.to change(destination, :stance).to(nil)
        end

        it 'returns destination' do
          expect(synchronize).to eq(destination)
        end
      end
    end
  end
end