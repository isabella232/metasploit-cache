RSpec.describe Metasploit::Cache::Exploit::Instance::Ephemeral::ExploitTargets do
  include_context 'ActiveSupport::TaggedLogging'

  context 'build_added' do
    subject(:build_added) {
      described_class.build_added(
          destination: destination,
          logger: logger,
          destination_attributes_by_name: destination_attributes_by_name,
          source_attributes_by_name: source_attributes_by_name
      )
    }

    let(:destination) {
      Metasploit::Cache::Exploit::Instance.new
    }

    let(:destination_attributes_by_name) {
      {}
    }

    context 'with added names' do
      let(:architecture_abbreviation_set) {
        Set.new [FactoryGirl.generate(:metasploit_cache_architecture_abbreviation)]
      }

      let(:index) {
        5
      }

      let(:name) {
        FactoryGirl.generate :metasploit_cache_exploit_target_name
      }

      let(:platform_fully_qualified_name_set) {
        Set.new [FactoryGirl.generate(:metasploit_cache_platform_fully_qualified_name)]
      }

      let(:source_attributes_by_name) {
        {
           name => {
               index: index,
               architecture_abbreviation_set: architecture_abbreviation_set,
               platform_fully_qualified_name_set: platform_fully_qualified_name_set
           }
        }
      }
      
      it 'adds element to #exploit_targets' do
        expect {
          build_added
        }.to change {
               destination.exploit_targets.length
             }.by(1)
      end
      
      context 'added Metasploit::Cache:Exploit::Target' do
        subject(:exploit_target) {
          build_added
          
          destination.exploit_targets.last
        }
        
        it 'sets Metasploit::Cache::Exploit::Target#architecturable_architectures using :architecture_abbreviation_set' do
          expect(exploit_target.architecturable_architectures.length).to eq(architecture_abbreviation_set.length)
          
          exploit_target_architecture_abbreviation_set = exploit_target.architecturable_architectures.each_with_object(Set.new) { |architecturable_architecture, set|
            set.add architecturable_architecture.architecture.abbreviation
          }
          
          expect(exploit_target_architecture_abbreviation_set).to eq(architecture_abbreviation_set)
        end

        it 'sets Metasploit::Cache::Exploit::Target#index using :index' do
          expect(exploit_target.index).to eq(index)
        end
        
        it 'sets Metasploit::Cache::Exploit::Target#platformable_platforms using :platform_fully_qualified_name_set' do
          expect(exploit_target.platformable_platforms.length).to eq(platform_fully_qualified_name_set.length)
          
          exploit_target_platform_fully_qualified_name_set = exploit_target.platformable_platforms.each_with_object(Set.new) { |architecturable_platform, set|
            set.add architecturable_platform.platform.fully_qualified_name
          }
          
          expect(exploit_target_platform_fully_qualified_name_set).to eq(platform_fully_qualified_name_set)
        end
      end
    end

    context 'without added names' do
      let(:source_attributes_by_name) {
        destination_attributes_by_name
      }

      it 'does not add #exploit_targets to destination' do
        expect {
          build_added
        }.not_to change {
                   destination.exploit_targets.length
                 }
      end

      it 'returns destination' do
        expect(build_added).to eq(destination)
      end
    end
  end

  context 'destination_attributes_by_name' do
    subject(:destination_attributes_by_name) {
      described_class.destination_attributes_by_name(destination)
    }

    context 'with new destination' do
      let(:destination) {
        Metasploit::Cache::Exploit::Instance.new
      }

      it { is_expected.to eq({}) }
    end

    context 'with persisted destination' do
      let(:destination) {
        FactoryGirl.create(:full_metasploit_cache_exploit_instance)
      }

      let(:exploit_target) {
        destination.exploit_targets.first
      }

      it 'has Metasploit::Cache::Exploit::Target#name as key' do
        expect(destination_attributes_by_name).to have_key(exploit_target.name)
      end

      context 'attributes for Metasploit::Cache::Exploit::Target#name key' do
        subject(:attributes) {
          destination_attributes_by_name.fetch(exploit_target.name)
        }

        it 'has Metasploit::Cache::Exploit::Target#index as :index' do
          expect(attributes).to have_key(:index)
          expect(attributes[:index]).to eq(exploit_target.index)
        end
      end
    end
  end

  context 'mark_removed_for_destruction' do
    subject(:mark_removed_for_destruction) {
      described_class.mark_removed_for_destruction(
          destination: destination,
          destination_attributes_by_name: destination_attributes_by_name,
          source_attributes_by_name: source_attributes_by_name
      )
    }

    context 'with new destination' do
      let(:destination) {
        Metasploit::Cache::Exploit::Instance.new
      }

      let(:destination_attributes_by_name) {
        {}
      }

      let(:source_attributes_by_name) {

      }

      it 'returns destination' do
        expect(mark_removed_for_destruction).to eq(destination)
      end
    end

    context 'with persisted destination' do
      let(:destination) {
        FactoryGirl.create(
            :full_metasploit_cache_exploit_instance,
            exploit_target_count: 2
        )
      }

      let(:first_exploit_target) {
        destination.exploit_targets.first
      }

      let(:second_exploit_target) {
        destination.exploit_targets.second
      }

      let(:destination_attributes_by_name) {
        {
            first_exploit_target.name => {
                index: first_exploit_target.index,
                architecture_abbreviation_set: Set.new([first_exploit_target.architecturable_architectures.first.architecture.abbreviation]),
                platform_fully_qualified_name_set: Set.new([first_exploit_target.platformable_platforms.first.platform.fully_qualified_name])
            },
            second_exploit_target.name => {
                index: second_exploit_target.index,
                architecture_abbreviation_set: Set.new([second_exploit_target.architecturable_architectures.first.architecture.abbreviation]),
                platform_fully_qualified_name_set: Set.new([second_exploit_target.platformable_platforms.first.platform.fully_qualified_name])
            }
        }
      }

      context 'with empty removed name set' do
        let(:source_attributes_by_name) {
          destination_attributes_by_name
        }

        it 'does not mark for destruction any #exploit_targets' do
          expect {
            mark_removed_for_destruction
          }.not_to change {
                     destination.exploit_targets.each.count(&:marked_for_destruction?)
                   }
        end

        it 'does not destroy any #exploit_targets' do
          expect {
            mark_removed_for_destruction
          }.not_to change(destination.exploit_targets, :count)
        end

        it 'returns destination' do
          expect(mark_removed_for_destruction).to eq(destination)
        end

        context 'with destination saved' do
          it 'does not destroy any #exploit_targets' do
            mark_removed_for_destruction

            expect {
              destination.save!
            }.not_to change(destination.exploit_targets, :count)
          end
        end
      end

      context 'with present removed name set' do
        let(:source_attributes_by_name) {
          destination_attributes_by_name.except(first_exploit_target.name)
        }

        it 'marks for destruction #exploit_targets with matching name' do
          expect {
            mark_removed_for_destruction
          }.to change {
                 destination.exploit_targets.each.count(&:marked_for_destruction?)
               }.by(1)
        end

        it 'does not destroy any #exploit_targets' do
          expect {
            mark_removed_for_destruction
          }.not_to change(destination.exploit_targets, :count)
        end

        it 'returns destination' do
          expect(mark_removed_for_destruction).to eq(destination)
        end

        context 'with destination saved' do
          it 'destroys removed target' do
            mark_removed_for_destruction

            expect {
              destination.save!
            }.to change(destination.exploit_targets, :count).by(-1)

            expect(destination.exploit_targets(true).first.name).to eq(second_exploit_target.name)
          end
        end
      end
    end
  end

  context 'name_set' do
    subject(:name_set) {
      described_class.name_set(attributes_by_name)
    }

    context 'with empty attributes_by_name' do
      let(:attributes_by_name) {
        {}
      }

      it { is_expected.to eq Set.new }
    end

    context 'with present attributes_by_name' do
      let(:attributes_by_name) {
        {
            first_name => nil,
            second_name => nil
        }
      }

      let(:first_name) {
        FactoryGirl.generate :metasploit_cache_exploit_target_name
      }

      let(:second_name) {
        FactoryGirl.generate :metasploit_cache_exploit_target_name
      }

      it 'is set of keys' do
        expect(name_set).to eq Set.new([first_name, second_name])
      end
    end
  end

  context 'source_default_exploit_target_index' do
    subject(:source_default_exploit_target_index) {
      described_class.source_default_exploit_target_index(source)
    }

    let(:index) {
      FactoryGirl.generate :metasploit_cache_exploit_target_index
    }

    let(:source) {
      double('exploit Metasploit Module instance', default_target: index)
    }

    it 'is source #default_target' do
      expect(source_default_exploit_target_index).to eq(source.default_target)
    end
  end

  context 'source_attributes_by_name' do
    subject(:source_attributes_by_name) {
      described_class.source_attributes_by_name(
          source,
          logger: logger
      )
    }

    let(:source) {
      double(
          'exploit Metasploit Module instance',
          arch: [source_architecture_abbreviation],
          platform: double(
                        'exploit Metasploit Module instance platform list',
                        platforms: [
                            double(
                                'exploit Metasploit Module instance platform',
                                realname: source_platform_fully_qualified_name
                            )
                        ]
          ),
          targets: targets
      )
    }

    let(:source_architecture_abbreviation) {
      FactoryGirl.generate :metasploit_cache_architecture_abbreviation
    }

    let(:source_platform_fully_qualified_name) {
      FactoryGirl.generate :metasploit_cache_platform_fully_qualified_name
    }

    context 'without source.targets' do
      let(:targets) {
        []
      }

      it { is_expected.to eq({}) }
    end

    context 'with source.targets' do
      let(:name) {
        FactoryGirl.generate :metasploit_cache_exploit_target_name
      }

      let(:target) {
        double(
            'exploit Metasploit Module instance target',
            arch: arch,
            name: name,
            platform: platform
        )
      }

      let(:targets) {
        [
            target
        ]
      }

      context 'with target.arch' do
        let(:arch) {
          [target_architecture_abbreviation]
        }

        let(:target_architecture_abbreviation) {
          FactoryGirl.generate :metasploit_cache_architecture_abbreviation
        }

        context 'with target.platform' do
          let(:platform) {
            double(
                'exploit Metasploit Module instance target platform list',
                platforms: [
                    double(
                        'exploit Metasploit Module instance target platform',
                        realname: target_platform_fully_qualified_name
                    )
                ]
            )
          }

          let(:target_platform_fully_qualified_name) {
            FactoryGirl.generate :metasploit_cache_platform_fully_qualified_name
          }

          it 'sets key to target.name' do
            expect(source_attributes_by_name).to have_key(target.name)
          end

          context 'attributes for target.name' do
            subject(:attributes) {
              source_attributes_by_name[target.name]
            }

            it 'sets :architecture_abbreviation_set to Set of target.arch' do
              expect(attributes[:architecture_abbreviation_set]).to eq(Set.new([target_architecture_abbreviation]))
            end

            it 'sets :index to index of target in source.targets' do
              expect(attributes[:index]).to eq 0
            end

            it 'sets :platform_fully_qualified_name_set to Set of target.platform.platforms' do
              expect(attributes[:platform_fully_qualified_name_set]).to eq(Set.new([target_platform_fully_qualified_name]))
            end
          end
        end

        context 'without target.platform' do
          let(:platform) {
            nil
          }

          it 'sets key to target.name' do
            expect(source_attributes_by_name).to have_key(target.name)
          end

          context 'attributes for target.name' do
            subject(:attributes) {
              source_attributes_by_name[target.name]
            }

            it 'sets :architecture_abbreviation_set to Set of target.arch' do
              expect(attributes[:architecture_abbreviation_set]).to eq(Set.new([target_architecture_abbreviation]))
            end

            it 'sets :index to index of target in source.targets' do
              expect(attributes[:index]).to eq 0
            end

            it 'sets :platform_fully_qualified_name_set to Set of source.platform.platforms' do
              expect(attributes[:platform_fully_qualified_name_set]).to eq(Set.new([source_platform_fully_qualified_name]))
            end
          end
        end
      end

      context 'without target.arch' do
        let(:arch) {
          nil
        }

        context 'with target.platform' do
          let(:platform) {
            double(
                'exploit Metasploit Module instance target platform list',
                platforms: [
                    double(
                        'exploit Metasploit Module instance target platform',
                        realname: target_platform_fully_qualified_name
                    )
                ]
            )
          }

          let(:target_platform_fully_qualified_name) {
            FactoryGirl.generate :metasploit_cache_platform_fully_qualified_name
          }

          it 'sets key to target.name' do
            expect(source_attributes_by_name).to have_key(target.name)
          end

          context 'attributes for target.name' do
            subject(:attributes) {
              source_attributes_by_name[target.name]
            }

            it 'sets :architecture_abbreviation_set to Set of source.arch' do
              expect(attributes[:architecture_abbreviation_set]).to eq(Set.new([source_architecture_abbreviation]))
            end

            it 'sets :index to index of target in source.targets' do
              expect(attributes[:index]).to eq 0
            end

            it 'sets :platform_fully_qualified_name_set to Set of target.platform.platforms' do
              expect(attributes[:platform_fully_qualified_name_set]).to eq(Set.new([target_platform_fully_qualified_name]))
            end
          end
        end

        context 'without target.platform' do
          let(:platform) {
            nil
          }

          it 'sets key to target.name' do
            expect(source_attributes_by_name).to have_key(target.name)
          end

          context 'attributes for target.name' do
            subject(:attributes) {
              source_attributes_by_name[target.name]
            }

            it 'sets :architecture_abbreviation_set to Set of source.arch' do
              expect(attributes[:architecture_abbreviation_set]).to eq(Set.new([source_architecture_abbreviation]))
            end

            it 'sets :index to index of target in source.targets' do
              expect(attributes[:index]).to eq 0
            end

            it 'sets :platform_fully_qualified_name_set to Set of source.platform.platforms' do
              expect(attributes[:platform_fully_qualified_name_set]).to eq(Set.new([source_platform_fully_qualified_name]))
            end
          end
        end
      end
    end
  end
  
  context 'synchronize' do
    subject(:synchronize) {
      described_class.synchronize(
          destination: destination,
          logger: logger,
          source: source
      )
    }

    #
    # lets
    #

    let(:destination) {
      Metasploit::Cache::Exploit::Instance.new
    }

    let(:source) {
      double(
          'exploit Metasploit Module instance',
          default_target: nil,
          targets: []
      )
    }
    
    it 'calls build_added' do
      expect(described_class).to receive(:build_added).with(
                                     hash_including(destination: destination)
                                 ).and_call_original

      synchronize
    end

    it 'calls mark_removed_for_destruction' do
      expect(described_class).to receive(:mark_removed_for_destruction).with(
                                     hash_including(destination: destination)
                                 ).and_call_original

      synchronize
    end
    
    it 'calls update_changed' do
      expect(described_class).to receive(:update_changed).with(
                                     hash_including(destination: destination)
                                 ).and_call_original

      synchronize
    end

    it 'calls update_default_exploit_target' do
      expect(described_class).to receive(:update_default_exploit_target).with(
                                     hash_including(
                                         destination: destination,
                                         source: source
                                     )
                                 ).and_call_original

      synchronize
    end
  end

  context 'update_changed' do
    subject(:update_changed) {
      described_class.update_changed(
          destination: destination,
          destination_attributes_by_name: destination_attributes_by_name,
          logger: logger,
          source_attributes_by_name: source_attributes_by_name
      )
    }

    context 'with new destination' do
      let(:destination) {
        Metasploit::Cache::Exploit::Instance.new
      }

      let(:destination_attributes_by_name) {
        {}
      }

      let(:source_attributes_by_name) {
        {}
      }

      it 'does not change destination.exploit_targets' do
        expect {
          update_changed
        }.not_to change(destination, :exploit_targets)
      end
    end

    context 'with persisted destination' do
      let(:destination) {
        FactoryGirl.create(:full_metasploit_cache_exploit_instance)
      }

      let(:destination_attributes_by_name) {
        {
            exploit_target.name => {
                architecture_abbreviation_set: Set.new([removed_architecture_abbreviation]),
                index: exploit_target.index,
                platform_fully_qualified_name_set: Set.new([removed_platform_fully_qualified_name])
            }
        }
      }

      let(:exploit_target) {
        destination.exploit_targets.first
      }

      let(:removed_architecture_abbreviation) {
        exploit_target.architecturable_architectures.first.architecture.abbreviation
      }

      let(:removed_platform_fully_qualified_name) {
        exploit_target.platformable_platforms.first.platform.fully_qualified_name
      }

      context 'with retained name set' do
        let(:added_architecture_abbreviation) {
          FactoryGirl.generate :metasploit_cache_architecture_abbreviation
        }

        let(:source_attributes_by_name) {
          {
              exploit_target.name => {
                  architecture_abbreviation_set: Set.new([added_architecture_abbreviation]),
                  index: source_index,
                  platform_fully_qualified_name_set: Set.new([added_platform_fully_qualified_name])
              }
          }
        }

        let(:source_index) {
          FactoryGirl.generate :metasploit_cache_exploit_target_index
        }

        let(:added_platform_fully_qualified_name) {
          FactoryGirl.generate :metasploit_cache_platform_fully_qualified_name
        }

        it 'does not change number of destination.exploit_targets' do
          expect {
            update_changed
          }.not_to change {
                     destination.exploit_targets.length
                   }
        end

        context 'changed Metasploit::Cache::Exploit::Target' do
          subject(:changed_exploit_target) {
            updated = update_changed
            updated.save!

            updated.reload.exploit_targets.first
          }

          it 'updates #index' do
            expect(changed_exploit_target.index).to eq(source_index)
          end

          context '#architecturable_architectures' do
            subject(:changed_architecture_abbreviations) {
              changed_exploit_target.architecturable_architectures.map { |architecturable_architecture|
                architecturable_architecture.architecture.abbreviation
              }
            }

            it 'does not include removed architecture' do
              expect(changed_architecture_abbreviations).not_to include(removed_architecture_abbreviation)
            end

            it 'includes added architecture' do
              expect(changed_architecture_abbreviations).to include(added_architecture_abbreviation)
            end
          end

          context '#platformable_platforms' do
            subject(:changed_platform_fully_qualified_names) {
              changed_exploit_target.platformable_platforms.map { |platformable_platform|
                platformable_platform.platform.fully_qualified_name
              }
            }

            it 'does not include removed platform' do
              expect(changed_platform_fully_qualified_names).not_to include(removed_platform_fully_qualified_name)
            end

            it 'includes added platform' do
              expect(changed_platform_fully_qualified_names).to include(added_platform_fully_qualified_name)
            end
          end
        end
      end

      context 'without retained name set' do
        let(:source_attributes_by_name) {
          {
              FactoryGirl.generate(:metasploit_cache_exploit_target_name) => {
                  architecture_abbreviation_set: Set.new([FactoryGirl.generate(:metasploit_cache_architecture_abbreviation)]),
                  index: FactoryGirl.generate(:metasploit_cache_exploit_target_index),
                  platform_fully_qualified_name_set: Set.new([FactoryGirl.generate(:metasploit_cache_platform_fully_qualified_name)])
              }
          }
        }

        it 'does not change destination.exploit_targets' do
          expect {
            update_changed
          }.not_to change(destination, :exploit_targets)
        end
      end
    end
  end

  context 'update_default_exploit_target' do
    subject(:update_default_exploit_target) {
      described_class.update_default_exploit_target(
          destination: destination,
          source: source
      )
    }

    let(:destination) {
      FactoryGirl.build(
          :full_metasploit_cache_exploit_instance,
          exploit_target_count: 2
      ).tap { |exploit_instance|
        exploit_instance.default_exploit_target = exploit_instance.exploit_targets.min_by(&:index)

        exploit_instance.save!
      }
    }

    context 'with source_default_exploit_target_index' do
      context 'matching a Metasploit::Cache::Exploit::Target#index' do
        let(:source) {
          double(
              'exploit Metasploit Module instance',
              default_target: destination.exploit_targets.map(&:index).max
          )
        }

        it 'changes destination.default_exploit_target' do
          expect {
            update_default_exploit_target
          }.to change(destination, :default_exploit_target)
        end
      end

      context 'not matching a Metasploit::Cache::Exploit::Target#index' do
        let(:source) {
          double(
              'exploit Metasploit Module instance',
              default_target: destination.exploit_targets.map(&:index).max + 1
          )
        }

        it 'sets destination.default_exploit_target to nil' do
          expect {
            update_default_exploit_target
          }.to change(destination, :default_exploit_target).to(nil)
        end
      end
    end

    context 'without source_default_epxloit_target_index' do
      let(:source) {
        double(
            'exploit Metasploit Module Instance',
            default_target: nil
        )
      }

      it 'set destination.default_exploit_target to nil' do
        expect {
          update_default_exploit_target
        }.to change(destination, :default_exploit_target).to(nil)
      end
    end
  end
end