# Normalizes exploit Metasploit Module instance `#stance`, which can be aggressive, passive, or both.  Aggressive and
# both are counted as aggressive, since any aggressiveness means the module can be used to start an attack on a target.
module Metasploit::Cache::Exploit::Instance::Ephemeral::Stance
  # Method to check for stance in `source_stance`.
  #
  # @param source_stance [Array<String>, String]
  # @return [#call(String)]
  def self.is_stance_method(source_stance)
    name = case source_stance
           when Array
             :include?
           else
             :==
           end

    source_stance.method(name)
  end

  # Synchronizes the `#stance` from exploit Metasploit MOdule instance `source` to persisted
  # {Metasploit::Cache::Exploit::Instance#stance} on `destination`.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #stance]
  # @param logger [ActiveSupport::TaggedLogger] logger already tagged with
  #   {Metasploit::Cache::Module::Ancestor#real_pathnam}.
  # @param source [#stance]
  # @return [Metasploit::Cache::Exploit::Instance, #stance] `destination`
  def self.synchronize(destination:, logger:, source:)
    is_source_stance = is_stance_method(source.stance)

    # reset to nil in case stance has changed to an unrecognized value
    destination.stance = nil

    Metasploit::Cache::Module::Stance::PRECEDENCE.each do |stance|
      if is_source_stance.(stance)
        destination.stance = stance

        break
      end
    end

    destination
  end
end