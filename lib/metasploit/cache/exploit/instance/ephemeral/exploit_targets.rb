# Synchronizes the persisten chace of {Metasploit::Cache::Exploit::Instance#exploit_targets} with the in-memory
# `#targets` on an exploit Metasploit Module instance.
module Metasploit::Cache::Exploit::Instance::Ephemeral::ExploitTargets
  #
  # Module Methods
  #

  # Builds new {Metasploit::Cache::Exploit::Instance#exploit_targets} on `destination`.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  # @param destination_attributes_by_name [Hash{String => Object}] Hash with {Metasploit::Cache::Exploit::Target#name}
  #   of `destination` keys.
  # @param source_attributes_by_name [Hash{String => Hash{architecture_abbreviation_set: Set<String>, index: Integer, platform_fully_qualified_name_set: Set<String>}}]
  #   Maps `target.name` to exploit Metasploit Module instance target attributes.
  # @return [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  def self.build_added(destination:, destination_attributes_by_name:, source_attributes_by_name:)
    destination_name_set = name_set(destination_attributes_by_name)
    source_name_set = name_set(source_attributes_by_name)
    added_name_set = Metasploit::Cache::Ephemeral::AttributeSet.added(
        destination: destination_name_set,
        source: source_name_set
    )

    unless added_name_set.empty?
      added_name_set.each do |name|
        attributes = source_attributes_by_name.fetch(name)

        target = destination.exploit_targets.build(
            index: attributes.fetch(:index),
            name: name
        )
        Metasploit::Cache::Architecturable::Ephemeral::ArchitecturableArchitectures.build_added(
            destination: target,
            destination_attribute_set: Set.new,
            source_attribute_set: attributes.fetch(:architecture_abbreviation_set)
        )
        Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.build_added(
            destination: target,
            destination_attribute_set: Set.new,
            source_attribute_set: attributes.fetch(:platform_fully_qualified_name_set)
        )
      end
    end

    destination
  end

  # Maps {Metasploit::Cache::Exploit::Target#name} to {Metasploit::Cache::Exploit::Target} attributes currently
  # persisted for {Metasploit::Cache::Exploit::Target}.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #exploit_targets] Persistent cache of exploit Metasploit
  #   Module instance.
  # @return [Hash{String => Hash{architecture_abbreviation_set: Set<String>, index: Integer, platform_fully_qualified_name_set: Set<String>}}]
  #   Maps {Metasploit::Cache::Exploit::Target#name} to other attributes.
  def self.destination_attributes_by_name(destination)
    if destination.new_record?
      {}
    else
      destination.exploit_targets.each_with_object({}) do |exploit_target, attributes_by_name|
        architecture_abbreviation_set = Metasploit::Cache::Architecturable::Ephemeral::ArchitecturableArchitectures.destination_attribute_set(
            exploit_target
        )
        platform_fully_qualified_name_set = Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.destination_attribute_set(
            exploit_target
        )

        name = exploit_target.name

        attributes = {
            architecture_abbreviation_set: architecture_abbreviation_set,
            index: exploit_target.index,
            platform_fully_qualified_name_set: platform_fully_qualified_name_set
        }

        attributes_by_name[name] = attributes
      end
    end
  end
  
  # Marks for destruction {#targets} on `destination` that are persisted to `destination`, but don't exist in `source`.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  # @param destination_attributes_by_name [Hash{String => Object}]
  #   Hash with {Metasploit::Cache::Exploit::Target#name} of `destination` keys.
  # @param source_attributes_by_name [Hash{String => Object}]
  #   Hash with `target.name` of exploit Metasploit Module instance target keys.
  # @return [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  def self.mark_removed_for_destruction(destination:, destination_attributes_by_name:, source_attributes_by_name:)
    unless destination.new_record?
      destination_name_set = name_set(destination_attributes_by_name)
      source_name_set = name_set(source_attributes_by_name)
      removed_name_set = Metasploit::Cache::Ephemeral::AttributeSet.removed(
          destination: destination_name_set,
          source: source_name_set
      )

      unless removed_name_set.empty?
        destination.exploit_targets.each do |exploit_target|
          if removed_name_set.include? exploit_target.name
            exploit_target.mark_for_destruction
          end
        end
      end
    end

    destination
  end

  # Set of names from `attributes_by_name` Hash
  #
  # @param attributes_by_name [Hash<{String: Object}>]
  # @return [Set<String>]
  def self.name_set(attributes_by_name)
    attributes_by_name.each_key.each_with_object(Set.new) do |name, set|
      set.add name
    end
  end

  # The index of the default target on the `source` exploit Metasploit Module instance.
  #
  # @param source [#default_target]
  # @return [nil] if no default target index
  # @return [Integer] if default target index
  def self.source_default_exploit_target_index(source)
    # The API in metasploit-framework just calls it `default_target` even though it is just an `Integer` index
    source.default_target
  end

  # Maps target name to other attributes from the `#targets` from the `source` exploit Metasploit Module instance.
  # Targets inherit their `:architecture_abbreviation_set` from the `source` `#arch` if the target has no architecture.
  # Targets inherit their :platform_fully_qualified_name_set` from the `source` `#platform` if the target has no
  # platforms.
  #
  # @param source [#targets] exploit Metasploit Module instance
  # @return [Hash{String => Hash{architecture_abbreviation_set: Set<String>, index: Integer, platform_fully_qualified_name_set: Set<String>}}]
  #   Maps target name to other attributes.
  def self.source_attributes_by_name(source)
    source_architecture_abbreviation_set = nil
    source_platform_fully_qualified_name_set = nil

    source.targets.each_with_index.each_with_object({}) do |(target, index), attributes_by_name|
      # @see https://github.com/rapid7/metasploit-framework/blob/7113c801b1bb332db0f63078ae8bad5dc9da9157/lib/msf/core/module/target.rb#L141-L144
      if target.arch.nil?
        source_architecture_abbreviation_set ||= Metasploit::Cache::Architecturable::Ephemeral::ArchitecturableArchitectures.source_attribute_set(source)
        architecture_abbreviation_set = source_architecture_abbreviation_set
      else
        architecture_abbreviation_set = Metasploit::Cache::Architecturable::Ephemeral::ArchitecturableArchitectures.source_attribute_set(target)
      end

      # @see https://github.com/rapid7/metasploit-framework/blob/7113c801b1bb332db0f63078ae8bad5dc9da9157/lib/msf/core/module/target.rb#L136
      if target.platform.nil?
        source_platform_fully_qualified_name_set ||= Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.source_attribute_set(source)
        platform_fully_qualified_name_set = source_platform_fully_qualified_name_set
      else
        platform_fully_qualified_name_set = Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.source_attribute_set(target)
      end

      attributes_by_name[target.name] = {
          architecture_abbreviation_set: architecture_abbreviation_set,
          index: index,
          platform_fully_qualified_name_set: platform_fully_qualified_name_set
      }
    end
  end

  # Synchronizes `#targets` and `#default_target` from Metasploit Module instance `source` to persisted
  # {Metasploit::Cache::Exploit::Instance#exploit_targets} and
  # {Metasploit::Cache::Exploit::Instance#default_exploit_target} on `destination`.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #default_exploit_target, #exploit_targets]
  # @param source [#default_target, #targets] an exploit Metasploit Module instance
  # @return [Metasploit::Cache::Exploit::Instance, #default_exploit_target, #exploit_targets] `destination`
  def self.synchronize(destination:, source:)
    Metasploit::Cache::Ephemeral.with_connection_transaction(destination_class: destination.class) {
      cached_destination_attributes_by_name = destination_attributes_by_name(destination)
      cached_source_attributes_by_name = source_attributes_by_name(source)

      reduced = [:mark_removed_for_destruction, :update_changed, :build_added].reduce(destination) { |block_destination, method|
        public_send(
            method,
            destination: block_destination,
            destination_attributes_by_name: cached_destination_attributes_by_name,
            source_attributes_by_name: cached_source_attributes_by_name
        )
      }
      update_default_exploit_target(
          destination: reduced,
          source: source
      )
    }
  end

  # Updates {Metasploit::Cache::Exploit::Instance#exploit_targets} on `destination` that have the same
  # {Metasploit::Cache::Exploit::Target#name} as `#targets` on source, but different
  # {Metasploit::Cache::Exploit::Target#architecturable_architectures}, {Metasploit::Cache::Exploit::Target#index}, or
  # {Metasploit::Cache::Exploit::Target#platformable_platforms}.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  # @param destination_attributes_by_name [Hash{String => Hash{architecture_abbreviation_set: Set<String>, index: Integer, platform_fully_qualified_name_set: Set<String>}}]
  # @param source_attributes_by_name [Hash{String => Hash{architecture_abbreviation_set: Set<String>, index: Integer, platform_fully_qualified_name_set: Set<String>}}]
  # @return [Metasploit::Cache::Exploit::Instance, #exploit_targets] `destination`
  def self.update_changed(destination:, destination_attributes_by_name:, source_attributes_by_name:)
    unless destination.new_record?
      destination_name_set = name_set(destination_attributes_by_name)
      source_name_set = name_set(source_attributes_by_name)
      retained_name_set = Metasploit::Cache::Ephemeral::AttributeSet.retained(
          destination: destination_name_set,
          source: source_name_set
      )

      unless retained_name_set.empty?
        exploit_target_by_name = destination.exploit_targets.each_with_object({}) { |exploit_target, hash|
          hash[exploit_target.name] = exploit_target
        }

        retained_name_set.each { |retained_name|
          destination_attributes = destination_attributes_by_name.fetch(retained_name)
          source_attributes = source_attributes_by_name.fetch(retained_name)

          exploit_target = exploit_target_by_name.fetch(retained_name)

          exploit_target.index = source_attributes.fetch(:index)

          destination_architecture_abbreviation_set = destination_attributes.fetch(:architecture_abbreviation_set)
          source_architecture_abbreviation_set = source_attributes.fetch(:architecture_abbreviation_set)

          Metasploit::Cache::Architecturable::Ephemeral::ArchitecturableArchitectures.reduce(
              destination: exploit_target,
              destination_attribute_set: destination_architecture_abbreviation_set,
              source_attribute_set: source_architecture_abbreviation_set
          )

          destination_platform_fully_qualified_name_set = destination_attributes.fetch(:platform_fully_qualified_name_set)
          source_platform_fully_qualified_name_set = source_attributes.fetch(:platform_fully_qualified_name_set)

          Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.reduce(
              destination: exploit_target,
              destination_attribute_set: destination_platform_fully_qualified_name_set,
              source_attribute_set: source_platform_fully_qualified_name_set
          )
        }
      end
    end

    destination
  end

  # Updates the {Metasploit::Cache::Exploit::Instance#default_exploit_target} on `destination`.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #default_exploit_target]
  # @param source [#default_target] exploit Metasploit Module instance
  # @return [Metasploit::Cache::Exploit::Instance, #default_exploit_target] `destination`
  def self.update_default_exploit_target(destination:, source:)
    # reset to `nil` because `source_default_exploit_target_index` may be invalid and point to a non-existent index
    destination.default_exploit_target = nil

    cached_source_default_exploit_target_index = source_default_exploit_target_index(source)

    if cached_source_default_exploit_target_index
      destination.exploit_targets.each do |exploit_target|
        if exploit_target.index == cached_source_default_exploit_target_index
          destination.default_exploit_target = exploit_target

          break
        end
      end
    end

    destination
  end
end