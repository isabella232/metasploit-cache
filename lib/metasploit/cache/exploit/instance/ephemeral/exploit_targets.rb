# Synchronizes the persisten chace of {Metasploit::Cache::Exploit::Instance#exploit_targets} with the in-memory
# `#targets` on an exploit Metasploit Module instance.
module Metasploit::Cache::Exploit::Instance::Ephemeral::ExploitTargets
  #
  # Module Methods
  #

  # Builds new {Metasploit::Cache::Exploit::Instance#exploit_targets} on `destination`.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  # @param destination_attributes_set [Set<Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}>]
  #   Set of {Metasploit::Cache::Exploit::Instance#exploit_targets} attributes of `destination`.
  # @param source_attributes_set [Set<Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}>]
  #   Set of exploit Metasploit Module instance target attributes.
  # @return [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  def self.build_added(destination:, destination_attributes_set:, source_attributes_set:)
    destination_name_set = name_set(destination_attributes_set)
    source_name_set = name_set(source_attributes_set)
    added_name_set = Metasploit::Cache::Ephemeral::AttributeSet.added(
        destination: destination_name_set,
        source: source_name_set
    )

    unless added_name_set.empty?
      source_attributes_by_name = by_name(source_attributes_set)

      added_name_set.each do |name|
        attributes = source_attributes_by_name.fetch(name)

        target = destination.exploit_targets.build(
            index: attributes.fetch(:index),
            name: attributes.fetch(:name)
        )
        Metasploit::Cache::Architecturable::Ephemeral::ArchitecturableArchitectures.build_added(
            destination: target,
            destination_attribute_set: Set.new,
            source_attribute_set: attributes.fetch(:architecture_abbreviation_set)
        )
        Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.build_added(
            destination: target,
            destination_attribute_set: Set.new,
            source_attribute_set: attributes.fetch(:platform_fully_qualified_name_set)
        )
      end
    end

    destination
  end

  # Maps `:name` values in each attributes Hash in `attribute_set` to that attributes Hash.
  #
  # @param attributes_set [Set<Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}>]
  # @return [Hash{String => Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}}]
  def self.by_name(attributes_set)
    attributes_set.each_with_object({}) do |attributes, attributes_by_name|
      attributes_by_name[attributes.fetch(:name)] = attributes
    end
  end

  # The set of {Metasploit::Cache::Exploit::Target} attributes currently persisted.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #exploit_targets] Persistent cache of exploit Metasploit
  #   Module instance.
  # @return [Set<Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}>]
  #   Set of target hashes.
  def self.destination_attributes_set(destination)
    if destination.new_record?
      Set.new
    else
      destination.exploit_targets.each_with_object(Set.new) do |exploit_target, set|
        architecture_abbreviation_set = Metasploit::Cache::Architecturable::Ephemeral::ArchitecturableArchitectures.destination_attribute_set(
            exploit_target
        )
        platform_fully_qualified_name_set = Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.destination_attribute_set(
            exploit_target
        )

        target_attributes = {
            architecture_abbreviation_set: architecture_abbreviation_set,
            index: exploit_target.index,
            name: exploit_target.name,
            platform_fully_qualified_name_set: platform_fully_qualified_name_set
        }

        set.add target_attributes
      end
    end
  end
  
  # Destroys {#targets} on `destination` that are persisted to `destination`, but don't exist in `source`.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  # @param destination_attributes_set [Set<Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}>]
  #   Set of {Metasploit::Cache::Exploit::Instance#exploit_targets} attributes of `destination`.
  # @param source_attributes_set [Set<Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}>]
  #   Set of exploit Metasploit Module instance target attributes.
  # @return [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  def self.destroy_removed(destination:, destination_attributes_set:, source_attributes_set:)
    unless destination.new_record?
      destination_name_set = name_set(destination_attributes_set)
      source_name_set = name_set(source_attributes_set)
      removed_name_set = Metasploit::Cache::Ephemeral::AttributeSet.removed(
          destination: destination_name_set,
          source: source_name_set
      )

      unless removed_name_set.empty?
        destination.exploit_targets.where(
            # AREL cannot visit Set
            name: removed_name_set.to_a
        ).destroy_all
      end
    end

    destination
  end

  # Set of names from attribute Hashes Set.
  #
  # @param attributes_set [Set<Hash<{name: String}>>]
  # @return [Set<String>]
  def self.name_set(attributes_set)
    attributes_set.each_with_object(Set.new) do |attributes, set|
      set.add attributes.fetch(:name)
    end
  end

  # The index of the default target on the `source` exploit Metasploit Module instance.
  #
  # @param source [#default_target]
  # @return [nil] if no default target index
  # @return [Integer] if default target index
  def self.source_default_exploit_target_index(source)
    # The API in metasploit-framework just calls it `default_target` even though it is just an `Integer` index
    source.default_target
  end

  # The set of attributes from the `#targets` from the `source` exploit Metasploit Module instance.  Targets inherit
  # their `:architecture_abbreviation_set` from the `source` `#arch` if the target has no architecture.  Targets inherit
  # their :platform_fully_qualified_name_set` from the `source` `#platform` if the target has no platforms.
  #
  # @param source [#targets] exploit Metasploit Module instance
  # @return [Set<Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}>] Set of target Hashes.
  def self.source_attributes_set(source)
    source_architecture_abbreviation_set = nil
    source_platform_fully_qualified_name_set = nil

    source.targets.each_with_index.each_with_object(Set.new) do |(target, index), set|
      # @see https://github.com/rapid7/metasploit-framework/blob/7113c801b1bb332db0f63078ae8bad5dc9da9157/lib/msf/core/module/target.rb#L136
      if target.platform.nil?
        source_architecture_abbreviation_set ||= Metasploit::Cache::Architecturable::Ephemeral::ArchitecturableArchitectures.source_attribute_set(source)
        architecture_abbreviation_set = source_architecture_abbreviation_set
      else
        architecture_abbreviation_set = Metasploit::Cache::Architecturable::Ephemeral::ArchitecturableArchitectures.source_attribute_set(target)
      end

      # @see https://github.com/rapid7/metasploit-framework/blob/7113c801b1bb332db0f63078ae8bad5dc9da9157/lib/msf/core/module/target.rb#L141-L144
      if target.arch.nil?
        source_platform_fully_qualified_name_set ||= Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.source_attribute_set(source)
        platform_fully_qualified_name_set = source_platform_fully_qualified_name_set
      else
        platform_fully_qualified_name_set = Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.source_attribute_set(target)
      end

      target_attributes = {
          architecture_abbreviation_set: architecture_abbreviation_set,
          index: index,
          name: target.name,
          platform_fully_qualified_name_set: platform_fully_qualified_name_set
      }

      set.add target_attributes
    end
  end

  # Synchronizes `#targets` and `#default_target` from Metasploit Module instance `source` to persisted
  # {Metasploit::Cache::Exploit::Instance#exploit_targets} and
  # {Metasploit::Cache::Exploit::Instance#default_exploit_target} on `destination`.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #default_exploit_target, #exploit_targets]
  # @param source [#default_target, #targets] an exploit Metasploit Module instance
  # @return [Metasploit::Cache::Exploit::Instance, #default_exploit_target, #exploit_targets] `destination`
  def self.synchronize(destination:, source:)
    Metasploit::Cache::Ephemeral.with_connection_transaction(destination_class: destination.class) {
      cached_destination_attributes_set = destination_attributes_set(destination)
      cached_source_attributes_set = source_attributes_set(source)

      reduced = destroy_removed(
          destination: destination,
          destination_attributes_set: cached_destination_attributes_set,
          source_attributes_set: cached_source_attributes_set
      )
      updated = update_changed(
          destination: reduced,
          destination_attributes_set: cached_destination_attributes_set,
          source_attributes_set: cached_source_attributes_set
      )
      expanded = build_added(
          destination: updated,
          destination_attributes_set: cached_destination_attributes_set,
          source_attributes_set: cached_source_attributes_set
      )
      update_default_exploit_target(
          destination: expanded,
          source: source
      )
    }
  end

  # Updates {Metasploit::Cache::Exploit::Instance#exploit_targets} on `destination` that have the same
  # {Metasploit::Cache::Exploit::Target#name} as `#targets` on source, but different
  # {Metasploit::Cache::Exploit::Target#architecturable_architectures}, {Metasploit::Cache::Exploit::Target#index}, or
  # {Metasploit::Cache::Exploit::Target#platformable_platforms}.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #exploit_targets]
  # @param destination_attributes_set [Set<Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}>]
  # @param source_attributes_set [Set<Hash{architecture_abbreviation_set: Set<String>, index: Integer, name: String, platform_fully_qualified_name_set: Set<String>}>]
  # @return [Metasploit::Cache::Exploit::Instance, #exploit_targets] `destination`
  def self.update_changed(destination:, destination_attributes_set:, source_attributes_set:)
    unless destination.new_record?
      destination_name_set = name_set(destination_attributes_set)
      source_name_set = name_set(source_attributes_set)
      retained_name_set = Metasploit::Cache::Ephemeral::AttributeSet.retained(
          destination: destination_name_set,
          source: source_name_set
      )

      unless retained_name_set.empty?
        destination_attributes_by_name = by_name(destination_attributes_set)
        source_attributes_by_name = by_name(source_attributes_set)

        destination = retained_name_set.reduce(destination) { |block_destination, retained_name|
          destination_attributes = destination_attributes_by_name.fetch(retained_name)
          source_attributes = source_attributes_by_name.fetch(retained_name)

          destination.index = destination_attributes.fetch(:index)

          destination_architecture_abbreviation_set = destination_attributes.fetch(:architecture_abbreviation_set)
          source_architecture_abbreviation_set = source_attributes.fetch(:architecture_abbreviation_set)

          architecturable_architectures_reduced = Metasploit::Cache::Architectureable::Ephemeral::ArchitecturableArchitectures.reduce(
              destination: block_destination,
              destination_attribute_set: destination_architecture_abbreviation_set,
              source_attribute_set: source_architecture_abbreviation_set
          )

          destination_platform_fully_qualified_name_set = destination_attributes.fetch(:platform_fully_qualified_name_set)
          source_platform_fully_qualified_name_set = source_attributes.fetch(:platform_fully_qualified_name_set)

          Metasploit::Cache::Platformable::Ephemeral::PlatformablePlatforms.reduce(
              destination: architecturable_architectures_reduced,
              destination_attribute_set: destination_platform_fully_qualified_name_set,
              source_attribute_set: source_platform_fully_qualified_name_set
          )
        }
      end
    end

    destination
  end

  # Updates the {Metasploit::Cache::Exploit::Instance#default_exploit_target} on `destination`.
  #
  # @param destination [Metasploit::Cache::Exploit::Instance, #default_exploit_target]
  # @param source [#default_target] exploit Metasploit Module instance
  # @return [Metasploit::Cache::Exploit::Instance, #default_exploit_target] `destination`
  def self.update_default_exploit_target(destination:, source:)
    cached_source_default_exploit_target_index = source_default_exploit_target_index(source)

    if cached_source_default_exploit_target_index
      # reset to `nil` because `source_default_exploit_target_index` may be invalid and point to a non-existent index
      destination.default_exploit_target = nil

      destination.exploit_targets.each do |exploit_target|
        if exploit_target.index == cached_source_default_exploit_target_index
          destination.default_exploit_target = exploit_target

          break
        end
      end
    end

    destination
  end
end